{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red27\green31\blue34;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c14118\c16078\c18039;\cssrgb\c100000\c100000\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww21360\viewh13660\viewkind0
\deftab720
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0
\f0\fs32 \cf2 \cb3 {\listtext	1.	}The language of preference is Kotlin.\
{\listtext	2.	}\expnd0\expndtw0\kerning0
The architecture that I have used is MVVM.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf2 \cb1 \kerning1\expnd0\expndtw0 {\listtext	3.	}It uses the Android Architecture Components.\
{\listtext	4.	}\expnd0\expndtw0\kerning0
Uses ktlintFormat. See https://github.com/shyiko/ktlint for more information, but, to summarise, fix all style violations automatically by running a gradle task.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 {\listtext	5.	}It uses Androidx.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf2 {\listtext	6.	}LiveData, This allows the components in your app to be able to observe LiveData objects for changes without creating explicit and rigid dependency paths between them. This decouples completely the LiveData object producer from the LiveData object consumer.\
{\listtext	7.	}Includes both unit tests and instrumentation tests.\
{\listtext	8.	}Has offline capability using ROOM database.\
{\listtext	9.	}\expnd0\expndtw0\kerning0
I have used the principles of singularity of responsibility and integration segregation ( SOLID ) and so kept the services separate.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 {\listtext	10.	}\expnd0\expndtw0\kerning0
I inject dependencies into the Presenter. Dependency Injection is a form of Dependency Inversion ( SOLID ). I am using Dagger 2 to facilitate Dependency Injection\cf2 \cb1 \kerning1\expnd0\expndtw0 \
{\listtext	11.	}Regarding Dagger injection, of presenters, if the task was more complicated, and for example, required several presenters ( if MVP was used ) , then I would have created a BasePresenter class, that would setup the injection , so, Presenters wouldn\'92t have to deal with setting up injection, except the function inject() that requires the object of the Presenter class to be passed into the inject function.\
{\listtext	12.	}I have called the Dagger component interface, PresenterInjector, instead of the usual naming convention. I hope that wasn\'92t confusing. Again, if we had multiple presenters, they would all be included in this file.\
\pard\tx566\pardeftab720\sl360\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
\
}